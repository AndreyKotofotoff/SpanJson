<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    var types = new[]
    {
        typeof(sbyte),
        typeof(Int16),
        typeof(Int32),
        typeof(Int64),
        typeof(byte),
        typeof(UInt16),
        typeof(UInt32),
        typeof(UInt64),
        typeof(Single),
        typeof(Double),
        typeof(decimal),
        typeof(bool),
        typeof(char),
        typeof(DateTime),
        typeof(DateTimeOffset),
        typeof(TimeSpan),
        typeof(Guid),
        typeof(Version),
        typeof(Uri)
    };
	var symbols = new[]
	{
		"Utf8",
		"Utf16",
	};

	var additionalMethods = new []
	{
		new {Name = "ReadBeginObjectOrThrow", ReturnType = "void", ArgumentModifier = string.Empty, Argument = string.Empty, ArgumentType = string.Empty},
		new {Name = "ReadBeginArrayOrThrow", ReturnType = "void", ArgumentModifier = string.Empty, Argument = string.Empty, ArgumentType = string.Empty},
		new {Name = "ReadIsNull", ReturnType = "bool", ArgumentModifier = string.Empty, Argument = string.Empty, ArgumentType = string.Empty},
		new {Name = "TryReadIsEndArrayOrValueSeparator", ReturnType = "bool", ArgumentModifier = "ref", Argument = "count", ArgumentType = "int"},
		new {Name = "TryReadIsEndObjectOrValueSeparator", ReturnType = "bool", ArgumentModifier = "ref", Argument = "count", ArgumentType = "int"},
	};
#>
// Autogenerated
// ReSharper disable BuiltInTypeReferenceStyle
// ReSharper disable ImpureMethodCallOnReadonlyValueField
using System.Runtime.CompilerServices;
using System;
namespace SpanJson
{
	public ref partial struct StreamingJsonReader<TSymbol> where TSymbol : struct
	{

<# foreach(var t in types) {
   foreach(var symbol in symbols) {
#>
      [MethodImpl(MethodImplOptions.AggressiveInlining)]
      public <#=t.Name#> Read<#=symbol#><#=t.Name #>()
      {	       
		  return _jsonReader.Read<#=symbol#><#=t.Name #>();
      }

<# } #>
      [MethodImpl(MethodImplOptions.AggressiveInlining)]
      public <#=t.Name#> Read<#=t.Name #>()
      {
          if (typeof(TSymbol) == typeof(char))
          {
              return _jsonReader.ReadUtf16<#=t.Name #>();
          }
		  
		  if (typeof(TSymbol) == typeof(byte))
          {
              return _jsonReader.ReadUtf8<#=t.Name #>();
          }

          ThrowNotSupportedException();
          return default;
      }
<# } #>
<# foreach(var t in additionalMethods) {
	  string returnValue = t.ReturnType == "void" ? string.Empty : "return";
   foreach(var symbol in symbols) {
   	  string methodName = t.Name.Replace("Read", "Read"+symbol);
#>
      [MethodImpl(MethodImplOptions.AggressiveInlining)]
      public <#=t.ReturnType#> <#=methodName#>(<#=t.ArgumentModifier#> <#=t.ArgumentType#> <#=t.Argument#>)
      {	       
		  <#=returnValue#> _jsonReader.<#=methodName#>(<#=t.ArgumentModifier#> <#=t.Argument#>);
      }
<# } #>
      [MethodImpl(MethodImplOptions.AggressiveInlining)]
      public <#=t.ReturnType#> <#=t.Name#>(<#=t.ArgumentModifier#> <#=t.ArgumentType#> <#=t.Argument#>)
      {
          if (typeof(TSymbol) == typeof(char))
          {
		      <#=returnValue#> _jsonReader.<#=t.Name.Replace("Read","ReadUtf16")#>(<#=t.ArgumentModifier#> <#=t.Argument#>);
          }
		  
		  if (typeof(TSymbol) == typeof(byte))
          {
		      <#=returnValue#> _jsonReader.<#=t.Name.Replace("Read","ReadUtf8")#>(<#=t.ArgumentModifier#> <#=t.Argument#>);
          }

          ThrowNotSupportedException();
          <#=t.ReturnType == "void" ? string.Empty : "return default;"#>
      }
<# } #>
  }
}